\section{Preliminaries}


The original Delta Correlating Prediction Tables algorithm can be seen in
algorithm \ref{alg:dcpt_orig}, as described in Grannæs et.
al.\cite{Grannaes481837}. Initially, the PC is looked up in a table of entries,
and if it is not found, a replacement entry is created. If it was in the table,
the new delta from the last address to the current is added to the list of
deltas. 


The tiered version of the DCPT exchanges the table of entries with different
tier tables, which are searched through sequentially. The TDCPT did not yield
any significant speedup, but did lower the memory footprint.


\begin{algorithm}
\footnotesize
\caption{Original DCPT \cite{Grannaes481837}}
  \begin{algorithmic}[1]
    \Procedure{DCPT}{Load address $PC$, Miss address $addr$}
      \State $r \gets \Call{TableLookUp}{PC}$ \\

      \If {$entry.pc \neq PC$}
        \State $entry.pc \gets PC$
        \State $entry.lastAddress \gets addr$
        \State $entry.deltas[\;] \gets \emptyset$
        \State $entry.lastPrefetch \gets 0$
      \ElsIf {$addr - entry.lastAddress \neq 0$}
        \State $entry.deltas[\;] \gets addr - entry.lastAddress$
        \State $entry.lastAddress \gets addr$ \\

        \State $candidates[\;] \gets \Call{DeltaCorrelation}{entry}$
        \State $prefetches[\;] \gets \Call{PrefetchFilter}{entry, candidates[\:]}$
        \State $\Call{IssuePrefetches}{prefetches[\:]}$
      \EndIf
    \EndProcedure
  \end{algorithmic}
  \label{alg:dcpt_orig}
\end{algorithm}


\subsection{Prefetcher Description}

Our prefetcher, Dynamically Tiered Delta Correlating Prediction
Tables aims to have dynamically sized tiers to improve upon the potential
pitfalls that the original TDCPT-prefetcher fell into. Additionally it will
gather some statistics about the hit-rates for the various tiers to attempt to
decide better what size the various tiers should be, and whether or not to tier
at all.

A tier is here understood in the same way as in Sømåen et al, that is, when
a new PC is encountered, it doesn't immediately take up the space of a full-size
table entry, but is instead placed in a table of new PCs, along with the address it
accessed, this table is hereafter refered to as Tier 1. While Sømåen et al. introduced
a second tier (Tier 2) for PCs that had been seen more than once, but hadn't yet
reached a point where they would have been seen enough times to generate the necessary
amount of deltas to perform any prefetching, we opted to skip this tier to keep our
solution a bit simpler with regards to the tiering structure. But to keep the language
consistent, we still refer to our tiers in the same regard as Sømåen et al. namely as Tier 1
for the short table, and Tier 3 for the full length entries.

To compensate for the varying usage patterns in the programs, our prefetcher uses the same
table-memory in two different ways, either it uses it as a pure Tier 3-only setup, which
would behave exactly like a pure DCTP solution, or it uses a small portion of this to make
room for a (comparably large) amount of Tier 1-elements. This should in theory help to buffer
against a sudden large flow tier 1-type PCs, and thus avoid removing Tier 3-entries too early.
However, to allow the parts of the programs that need more Tier 3 elements than what is available
when using some of the table for Tier 1, the prefetcher will switch between the tiered operation mode
, and pure DCTP as follows:

As an access happens, the algorithm checks if the PC accessed is in T3. If it's
not, and the state is tiered mode, the PC will be moved from T1 to T3 if it is
already in T1, or just added to T1. However, if the state is in tier 3 only
mode, a check is done to see if the amount of T1 hits are high enough. The
thought behind this is that if a certain percentage of the hits are in T1
already, we can assume that more of the hits will be there, and we will switch
to tiered mode. Exactly what the percentage of hits should be enough to
switch should be decided experimentally.

In the same way, if the entry is already in T3, a switch from tiered mode to
tier 3 only mode is performed if the T1 ratio is lower than a set limit.

% TODO: Fill in more when the architecture becomes a bit clearer.

\subsection{Methodology}

We will be investigating the value of dynamically tiering the DCPT by
implementing the algorithm in software and testing it with a subset of the SPEC
CPU2000 benchmark.  The algorithm will be implemented in C and run on the M5
simulator, running on the Kongull cluster at NTNU.
